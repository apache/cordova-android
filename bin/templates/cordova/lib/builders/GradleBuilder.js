/*
       Licensed to the Apache Software Foundation (ASF) under one
       or more contributor license agreements.  See the NOTICE file
       distributed with this work for additional information
       regarding copyright ownership.  The ASF licenses this file
       to you under the Apache License, Version 2.0 (the
       "License"); you may not use this file except in compliance
       with the License.  You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing,
       software distributed under the License is distributed on an
       "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
       KIND, either express or implied.  See the License for the
       specific language governing permissions and limitations
       under the License.
*/

var Q = require('q');
var fs = require('fs');
var path = require('path');
var shell = require('shelljs');
// TODO: replace with cordova-common's superspawn
var spawn = require('../spawn');
var check_reqs = require('../check_reqs');

var util = require("util");
var GenericBuilder = require('./GenericBuilder');

var ROOT = path.resolve(__dirname, '../../..');
var MARKER = 'YOUR CHANGES WILL BE ERASED!';
var SIGNING_PROPERTIES = '-signing.properties';
var TEMPLATE =
    '# This file is automatically generated.\n' +
    '# Do not modify this file -- ' + MARKER + '\n';

function GradleBuilder (eventEmitter) {
    GenericBuilder.call(this, eventEmitter);
}

util.inherits(GradleBuilder, GenericBuilder);

GradleBuilder.prototype.getArgs = function(cmd, opts) {
    if (cmd == 'release') {
        cmd = 'cdvBuildRelease';
    } else if (cmd == 'debug') {
        cmd = 'cdvBuildDebug';
    }
    var args = [cmd, '-b', path.join(ROOT, 'build.gradle')];
    if (opts.arch) {
        args.push('-PcdvBuildArch=' + opts.arch);
    }

    // 10 seconds -> 6 seconds
    args.push('-Dorg.gradle.daemon=true');
    args.push.apply(args, opts.extraArgs);
    // Shaves another 100ms, but produces a "try at own risk" warning. Not worth it (yet):
    // args.push('-Dorg.gradle.parallel=true');
    return args;
};

// Makes the project buildable, minus the gradle wrapper.
GradleBuilder.prototype.prepBuildFiles = function() {
    var projectPath = ROOT;
    // Update the version of build.gradle in each dependent library.
    var pluginBuildGradle = path.join(projectPath, 'cordova', 'lib', 'plugin-build.gradle');
    var propertiesObj = readProjectProperties();
    var subProjects = propertiesObj.libs;
    for (var i = 0; i < subProjects.length; ++i) {
        if (subProjects[i] !== 'CordovaLib') {
            shell.cp('-f', pluginBuildGradle, path.join(ROOT, subProjects[i], 'build.gradle'));
        }
    }

    var name = extractRealProjectNameFromManifest(ROOT);
    //Remove the proj.id/name- prefix from projects: https://issues.apache.org/jira/browse/CB-9149
    var settingsGradlePaths =  subProjects.map(function(p){
        var realDir=p.replace(/[/\\]/g, ':');
        var libName=realDir.replace(name+'-','');
        var str='include ":'+libName+'"\n';
        if(realDir.indexOf(name+'-')!==-1)
            str+='project(":'+libName+'").projectDir = new File("'+p+'")\n';
        return str;
    });

    // Write the settings.gradle file.
    fs.writeFileSync(path.join(projectPath, 'settings.gradle'),
        '// GENERATED FILE - DO NOT EDIT\n' +
        'include ":"\n' + settingsGradlePaths.join(''));
    // Update dependencies within build.gradle.
    var buildGradle = fs.readFileSync(path.join(projectPath, 'build.gradle'), 'utf8');
    var depsList = '';
    subProjects.forEach(function(p) {
        var libName=p.replace(/[/\\]/g, ':').replace(name+'-','');
        depsList += '    debugCompile project(path: "' + libName + '", configuration: "debug")\n';
        depsList += '    releaseCompile project(path: "' + libName + '", configuration: "release")\n';
    });
    // For why we do this mapping: https://issues.apache.org/jira/browse/CB-8390
    var SYSTEM_LIBRARY_MAPPINGS = [
        [/^\/?extras\/android\/support\/(.*)$/, 'com.android.support:support-$1:+'],
        [/^\/?google\/google_play_services\/libproject\/google-play-services_lib\/?$/, 'com.google.android.gms:play-services:+']
    ];
    propertiesObj.systemLibs.forEach(function(p) {
        var mavenRef;
        // It's already in gradle form if it has two ':'s
        if (/:.*:/.exec(p)) {
            mavenRef = p;
        } else {
            for (var i = 0; i < SYSTEM_LIBRARY_MAPPINGS.length; ++i) {
                var pair = SYSTEM_LIBRARY_MAPPINGS[i];
                if (pair[0].exec(p)) {
                    mavenRef = p.replace(pair[0], pair[1]);
                    break;
                }
            }
            if (!mavenRef) {
                throw new Error('Unsupported system library (does not work with gradle): ' + p);
            }
        }
        depsList += '    compile "' + mavenRef + '"\n';
    });
    buildGradle = buildGradle.replace(/(SUB-PROJECT DEPENDENCIES START)[\s\S]*(\/\/ SUB-PROJECT DEPENDENCIES END)/, '$1\n' + depsList + '    $2');
    var includeList = '';
    propertiesObj.gradleIncludes.forEach(function(includePath) {
        includeList += 'apply from: "' + includePath + '"\n';
    });
    buildGradle = buildGradle.replace(/(PLUGIN GRADLE EXTENSIONS START)[\s\S]*(\/\/ PLUGIN GRADLE EXTENSIONS END)/, '$1\n' + includeList + '$2');
    fs.writeFileSync(path.join(projectPath, 'build.gradle'), buildGradle);
};

GradleBuilder.prototype.prepEnv = function(opts) {
    var self = this;
    return check_reqs.check_gradle()
    .then(function() {
        return self.prepBuildFiles();
    }).then(function() {
        // Copy the gradle wrapper on each build so that:
        // A) we don't require the Android SDK at project creation time, and
        // B) we always use the SDK's latest version of it.
        var projectPath = ROOT;
        // check_reqs ensures that this is set.
        var sdkDir = process.env['ANDROID_HOME'];
        var wrapperDir = path.join(sdkDir, 'tools', 'templates', 'gradle', 'wrapper');
        if (process.platform == 'win32') {
            shell.rm('-f', path.join(projectPath, 'gradlew.bat'));
            shell.cp(path.join(wrapperDir, 'gradlew.bat'), projectPath);
        } else {
            shell.rm('-f', path.join(projectPath, 'gradlew'));
            shell.cp(path.join(wrapperDir, 'gradlew'), projectPath);
        }
        shell.rm('-rf', path.join(projectPath, 'gradle', 'wrapper'));
        shell.mkdir('-p', path.join(projectPath, 'gradle'));
        shell.cp('-r', path.join(wrapperDir, 'gradle', 'wrapper'), path.join(projectPath, 'gradle'));

        // If the gradle distribution URL is set, make sure it points to version we want.
        // If it's not set, do nothing, assuming that we're using a future version of gradle that we don't want to mess with.
        // For some reason, using ^ and $ don't work.  This does the job, though.
        var distributionUrlRegex = /distributionUrl.*zip/;
        var distributionUrl = process.env['CORDOVA_ANDROID_GRADLE_DISTRIBUTION_URL'] || 'http\\://services.gradle.org/distributions/gradle-2.2.1-all.zip';
        var gradleWrapperPropertiesPath = path.join(projectPath, 'gradle', 'wrapper', 'gradle-wrapper.properties');
        shell.chmod('u+w', gradleWrapperPropertiesPath);
        shell.sed('-i', distributionUrlRegex, 'distributionUrl='+distributionUrl, gradleWrapperPropertiesPath);

        var propertiesFile = opts.buildType + SIGNING_PROPERTIES;
        var propertiesFilePath = path.join(ROOT, propertiesFile);
        if (opts.packageInfo) {
            fs.writeFileSync(propertiesFilePath, TEMPLATE + opts.packageInfo.toProperties());
        } else if (isAutoGenerated(propertiesFilePath)) {
            shell.rm('-f', propertiesFilePath);
        }
    });
};

/*
 * Builds the project with gradle.
 * Returns a promise.
 */
GradleBuilder.prototype.build = function(opts) {
    var self = this;
    var wrapper = path.join(ROOT, 'gradlew');
    var args = this.getArgs(opts.buildType == 'debug' ? 'debug' : 'release', opts);
    return Q().then(function() {
        self.events.emit('verbose', 'Running: ' + wrapper + ' ' + args.join(' '));
        return spawn(wrapper, args);
    });
};

GradleBuilder.prototype.clean = function(opts) {
    var builder = this;
    var wrapper = path.join(ROOT, 'gradlew');
    var args = builder.getArgs('clean', opts);
    return Q().then(function() {
        builder.events.emit('verbose', 'Running: ' + wrapper + ' ' + args.join(' '));
        return spawn(wrapper, args);
    });
};

GradleBuilder.prototype.findOutputApks = function(build_type, arch) {
    var binDir = path.join(ROOT, 'build', 'outputs', 'apk');
    return GenericBuilder.findOutputApksHelper(binDir, build_type, arch);
};

module.exports = GradleBuilder;


function readProjectProperties() {
    var data = fs.readFileSync(path.join(ROOT, 'project.properties'), 'utf8');
    return {
        libs: findAllUniq(data, /^\s*android\.library\.reference\.\d+=(.*)(?:\s|$)/mg),
        gradleIncludes: findAllUniq(data, /^\s*cordova\.gradle\.include\.\d+=(.*)(?:\s|$)/mg),
        systemLibs: findAllUniq(data, /^\s*cordova\.system\.library\.\d+=(.*)(?:\s|$)/mg)
    };
}

function findAllUniq(data, r) {
    var s = {};
    var m;
    while ((m = r.exec(data))) {
        s[m[1]] = 1;
    }
    return Object.keys(s);
}

function extractRealProjectNameFromManifest(projectPath) {
    var manifestPath = path.join(projectPath, 'AndroidManifest.xml');
    var manifestData = fs.readFileSync(manifestPath, 'utf8');
    var m = /<manifest[\s\S]*?package\s*=\s*"(.*?)"/i.exec(manifestData);
    if (!m) {
        throw new Error('Could not find package name in ' + manifestPath);
    }

    var packageName=m[1];
    var lastDotIndex = packageName.lastIndexOf('.');
    return packageName.substring(lastDotIndex + 1);
}

function isAutoGenerated(file) {
    if(fs.existsSync(file)) {
        var fileContents = fs.readFileSync(file, 'utf8');
        return fileContents.indexOf(MARKER) > 0;
    }
    return false;
}
